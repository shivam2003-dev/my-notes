# Docker Troubleshooting Cheatsheet: Container Lifecycle Problems

## Container Won't Start

### Exit Code Analysis

**Understanding Exit Codes**
```bash
# Check container exit status
docker ps -a
docker inspect <container_id> --format='{{.State.ExitCode}}'

# Get detailed container state
docker inspect <container_id> | grep -A 10 "State"
```

**Common Exit Codes & Solutions**

| Exit Code | Meaning | Common Causes | Solution |
|-----------|---------|---------------|----------|
| 0 | Success | Normal termination | No action needed |
| 1 | General Error | Command not found, syntax error | Check CMD/ENTRYPOINT |
| 2 | Misuse | Invalid command arguments | Verify command syntax |
| 125 | Docker Daemon Error | Invalid docker run command | Fix docker command |
| 126 | Permission Denied | Executable not found/permitted | Check file permissions |
| 127 | Command Not Found | Invalid command in CMD/ENTRYPOINT | Verify executable path |
| 128+n | Fatal Error Signal | Killed by signal (n) | Check system resources |
| 130 | SIGINT | Interrupted by Ctrl+C | Normal interrupt |
| 137 | SIGKILL | Killed (OOM or manual) | Check memory limits |
| 139 | SIGSEGV | Segmentation fault | Debug application |

### Startup Failures

**Image Issues**
```bash
# Check if image exists
docker images | grep <image_name>

# Pull missing image
docker pull <image_name>

# Build image if Dockerfile exists
docker build -t <image_name> .

# Check image layers
docker history <image_name>
```

**Command/Entrypoint Problems**
```bash
# Test command interactively
docker run -it <image_name> /bin/bash
docker run -it <image_name> sh

# Override entrypoint
docker run -it --entrypoint="" <image_name> /bin/bash

# Check default command
docker inspect <image_name> | grep -A 5 -B 5 "Cmd\|Entrypoint"
```

**Environment Variables**
```bash
# Check required environment variables
docker inspect <image_name> | grep -A 10 "Env"

# Run with environment variables
docker run -e VAR1=value1 -e VAR2=value2 <image_name>

# Load from file
docker run --env-file .env <image_name>
```

### Initialization Problems

**File System Issues**
```bash
# Check file permissions in image
docker run --rm <image_name> ls -la /

# Fix permission issues
docker run --rm <image_name> chmod +x /app/script.sh

# Check working directory
docker run --rm <image_name> pwd
```

**Dependency Problems**
```bash
# Check for missing dependencies
docker run --rm <image_name> ldd /app/binary

# Install missing packages (for testing)
docker run -it <image_name> sh
# Inside container: apt-get update && apt-get install <package>
```

## Container Keeps Stopping

### Unexpected Exits

**Monitor Container Behavior**
```bash
# Watch container status in real-time
watch -n 1 'docker ps -a'

# Follow container logs
docker logs -f <container_name>

# Get last few log entries
docker logs --tail 50 <container_name>

# Check logs with timestamps
docker logs -t <container_name>
```

**Application Crashes**
```bash
# Run container with restart policy
docker run --restart=unless-stopped <image_name>
docker run --restart=on-failure:5 <image_name>

# Debug with interactive mode
docker run -it <image_name> /bin/bash

# Keep container running for debugging
docker run -d --name debug <image_name> tail -f /dev/null
```

### Resource Constraints

**Memory Issues**
```bash
# Check memory usage
docker stats <container_name>

# Check memory limits
docker inspect <container_name> | grep -i memory

# Run with specific memory limit
docker run -m 512m <image_name>

# Monitor memory in real-time
docker exec <container_name> cat /proc/meminfo
```

**CPU Throttling**
```bash
# Check CPU usage
docker stats --no-stream <container_name>

# Set CPU limits
docker run --cpus="1.5" <image_name>
docker run --cpu-shares=512 <image_name>

# Check CPU constraints
docker inspect <container_name> | grep -A 5 "CpuShares\|CpuQuota"
```

### Health Check Failures

**Configure Health Checks**
```bash
# Add health check to Dockerfile
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8080/health || exit 1

# Run with health check
docker run --health-cmd="curl -f http://localhost:8080 || exit 1" \
           --health-interval=30s \
           --health-retries=3 \
           --health-timeout=5s \
           <image_name>
```

**Debug Health Checks**
```bash
# Check health status
docker inspect <container_name> | grep -A 10 Health

# View health check logs
docker inspect <container_name> --format='{{json .State.Health}}' | jq

# Test health check manually
docker exec <container_name> curl -f http://localhost:8080/health
```

## Container Resource Issues

### Memory Management

**Diagnose Memory Problems**
```bash
# Check system memory
free -h
cat /proc/meminfo

# Container memory stats
docker exec <container_name> cat /proc/meminfo
docker exec <container_name> free -h

# Check for OOM kills
dmesg | grep -i "killed process"
journalctl -u docker.service | grep -i oom
```

**Memory Optimization**
```bash
# Set memory limits and swap
docker run -m 1g --memory-swap 2g <image_name>

# Disable OOM killer for container
docker run --oom-kill-disable -m 1g <image_name>

# Monitor memory usage over time
docker stats --format "table {{.Container}}\t{{.MemUsage}}\t{{.MemPerc}}"
```

### CPU Management

**CPU Diagnostics**
```bash
# Check CPU usage
top
htop
docker exec <container_name> top

# Check CPU constraints
docker exec <container_name> cat /proc/cpuinfo
docker exec <container_name> nproc
```

**CPU Optimization**
```bash
# Set CPU limits
docker run --cpus="2" <image_name>                    # 2 CPU cores
docker run --cpu-period=100000 --cpu-quota=50000 <image_name>  # 50% of 1 core

# CPU affinity
docker run --cpuset-cpus="0,1" <image_name>          # Use cores 0 and 1
```

### Disk Space Problems

**Storage Diagnostics**
```bash
# Check disk usage
df -h
docker system df

# Container-specific disk usage
docker exec <container_name> df -h

# Check Docker root directory usage
du -sh /var/lib/docker/
```

**Storage Cleanup**
```bash
# Clean up Docker system
docker system prune -a
docker image prune -a
docker container prune
docker volume prune

# Remove unused containers
docker container rm $(docker container ls -aq)

# Check and clean logs
sudo du -sh /var/lib/docker/containers/*/
sudo truncate -s 0 /var/lib/docker/containers/*/*-json.log
```

## Port Binding & Networking Basics

### Port Conflicts

**Diagnose Port Issues**
```bash
# Check if port is already in use
netstat -tulpn | grep :<port>
ss -tulpn | grep :<port>
lsof -i :<port>

# Check Docker port mappings
docker port <container_name>
docker ps --format "table {{.Names}}\t{{.Ports}}"
```

**Resolve Port Conflicts**
```bash
# Kill process using port
sudo kill -9 $(lsof -t -i:<port>)

# Find alternative port
docker run -p 8081:80 <image_name>        # Use port 8081 instead of 8080

# Use random port assignment
docker run -P <image_name>                # Docker assigns random ports
```

### Binding Failures

**Common Binding Issues**
```bash
# Bind to specific interface
docker run -p 127.0.0.1:8080:80 <image_name>    # Localhost only
docker run -p 0.0.0.0:8080:80 <image_name>      # All interfaces

# Check port binding errors
docker logs <container_name> | grep -i "bind\|port\|address"

# Test port connectivity
telnet localhost 8080
nc -zv localhost 8080
```

**Permission Issues with Privileged Ports**
```bash
# Ports < 1024 require root or capabilities
docker run --cap-add=NET_BIND_SERVICE -p 80:80 <image_name>

# Alternative: use non-privileged ports
docker run -p 8080:80 <image_name>

# Run as root user
docker run --user root -p 80:80 <image_name>
```

### Localhost Access Issues

**Container-to-Host Communication**
```bash
# Access host from container (Linux)
docker run --add-host=host.docker.internal:host-gateway <image_name>

# Access host from container (Windows/macOS)
# Use host.docker.internal automatically available

# Test connectivity
docker exec <container_name> ping host.docker.internal
docker exec <container_name> curl http://host.docker.internal:8080
```

**Host-to-Container Communication**
```bash
# Get container IP
docker inspect <container_name> | grep IPAddress

# Test container connectivity
docker exec <container_name> netstat -tulpn
docker exec <container_name> ss -tulpn

# Check if service is listening
docker exec <container_name> curl localhost:80
```

## Quick Diagnostic Commands

### Container State Analysis
```bash
# Complete container inspection
docker inspect <container_name> | jq '.[]|{State,Config,NetworkSettings,Mounts}'

# Resource usage snapshot
docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.MemPerc}}"

# Port and network info
docker inspect <container_name> --format='{{.NetworkSettings.Ports}}'
```

### Log Analysis
```bash
# Structured log viewing
docker logs --since=1h --until=30m <container_name>
docker logs --tail=100 -t <container_name>

# Follow logs with grep
docker logs -f <container_name> | grep -i error
```

### Quick Fixes Reference

| Problem | Quick Diagnostic | Quick Fix |
|---------|------------------|-----------|
| Exit code 137 | `docker logs <container>` | Increase memory: `-m 2g` |
| Port in use | `lsof -i :8080` | Use different port: `-p 8081:80` |
| Container stops | `docker logs -f <container>` | Add restart policy: `--restart=unless-stopped` |
| Permission denied | `docker logs <container>` | Run as root: `--user root` |
| Command not found | `docker exec -it <container> bash` | Check PATH in container |
| Health check failing | `docker inspect <container>` | Debug health check command |
| Memory issues | `docker stats <container>` | Increase limits: `-m 4g --memory-swap 8g` |
| Can't connect to port | `docker port <container>` | Check port mapping: `-p host:container` |

This comprehensive guide covers container lifecycle problems with practical diagnostics and solutions for each scenario.

Sources
